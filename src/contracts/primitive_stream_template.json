{
  "name": "primitive_stream_db_name",
  "owner": "",
  "extensions": null,
  "tables": [
    {
      "name": "primitive_events",
      "columns": [
        {
          "name": "date_value",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          },
          "attributes": [
            {
              "type": "NOT_NULL",
              "value": ""
            },
            {
              "type": "MIN_LENGTH",
              "value": "10"
            },
            {
              "type": "MAX_LENGTH",
              "value": "10"
            }
          ]
        },
        {
          "name": "value",
          "type": {
            "name": "decimal",
            "is_array": false,
            "metadata": [36, 18]
          },
          "attributes": [
            {
              "type": "NOT_NULL",
              "value": ""
            }
          ]
        },
        {
          "name": "created_at",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          },
          "attributes": [
            {
              "type": "NOT_NULL",
              "value": ""
            }
          ]
        }
      ],
      "indexes": [
        {
          "name": "identifier_idx",
          "columns": ["date_value", "created_at"],
          "type": "PRIMARY"
        }
      ],
      "foreign_keys": null
    },
    {
      "name": "metadata",
      "columns": [
        {
          "name": "row_id",
          "type": {
            "name": "uuid",
            "is_array": false,
            "metadata": [0, 0]
          },
          "attributes": [
            {
              "type": "PRIMARY_KEY",
              "value": ""
            },
            {
              "type": "NOT_NULL",
              "value": ""
            }
          ]
        },
        {
          "name": "metadata_key",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          },
          "attributes": [
            {
              "type": "NOT_NULL",
              "value": ""
            }
          ]
        },
        {
          "name": "value_i",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          },
          "attributes": null
        },
        {
          "name": "value_f",
          "type": {
            "name": "decimal",
            "is_array": false,
            "metadata": [36, 18]
          },
          "attributes": null
        },
        {
          "name": "value_b",
          "type": {
            "name": "bool",
            "is_array": false,
            "metadata": [0, 0]
          },
          "attributes": null
        },
        {
          "name": "value_s",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          },
          "attributes": null
        },
        {
          "name": "value_ref",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          },
          "attributes": null
        },
        {
          "name": "created_at",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          },
          "attributes": [
            {
              "type": "NOT_NULL",
              "value": ""
            }
          ]
        },
        {
          "name": "disabled_at",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          },
          "attributes": null
        }
      ],
      "indexes": [
        {
          "name": "key_idx",
          "columns": ["metadata_key"],
          "type": "BTREE"
        },
        {
          "name": "ref_idx",
          "columns": ["value_ref"],
          "type": "BTREE"
        },
        {
          "name": "created_idx",
          "columns": ["created_at"],
          "type": "BTREE"
        }
      ],
      "foreign_keys": null
    }
  ],
  "actions": null,
  "procedures": [
    {
      "name": "is_initiated",
      "parameters": null,
      "public": false,
      "modifiers": ["VIEW"],
      "body": "for $row in SELECT * FROM metadata WHERE metadata_key = 'type' LIMIT 1 {\n        return true;\n    }\n\n    return false;",
      "return_types": {
        "is_table": false,
        "fields": [
          {
            "name": "result",
            "type": {
              "name": "bool",
              "is_array": false,
              "metadata": [0, 0]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "is_stream_owner",
      "parameters": [
        {
          "name": "$wallet",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": ["VIEW"],
      "body": "for $row in SELECT * FROM metadata WHERE metadata_key = 'stream_owner' AND value_ref = LOWER($wallet) LIMIT 1 {\n        return true;\n    }\n    return false;",
      "return_types": {
        "is_table": false,
        "fields": [
          {
            "name": "result",
            "type": {
              "name": "bool",
              "is_array": false,
              "metadata": [0, 0]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "is_wallet_allowed_to_write",
      "parameters": [
        {
          "name": "$wallet",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": ["VIEW"],
      "body": "if is_stream_owner($wallet) {\n        return true;\n    }\n\n    // if there's metadata allow_write_wallet -\u003e \u003cwallet\u003e, then its permitted\n    for $row in SELECT * FROM get_metadata('allow_write_wallet', false, $wallet) {\n        return true;\n    }\n\n    return false;",
      "return_types": {
        "is_table": false,
        "fields": [
          {
            "name": "value",
            "type": {
              "name": "bool",
              "is_array": false,
              "metadata": [0, 0]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "is_wallet_allowed_to_read",
      "parameters": [
        {
          "name": "$wallet",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": ["VIEW"],
      "body": "$visibility int := 0;\n    for $v_row in SELECT * FROM get_metadata('read_visibility', true, null) {\n        $visibility := $v_row.value_i;\n    }\n\n    if $visibility == 0 {\n        return true;\n    }\n\n    // if it's the owner, it's permitted\n    if is_stream_owner($wallet) {\n        return true;\n    }\n\n    // if there's metadata allow_read_wallet -\u003e \u003cwallet\u003e, then its permitted\n    for $row in SELECT * FROM get_metadata('allow_read_wallet', false, $wallet) {\n        return true;\n    }\n\n    return false;",
      "return_types": {
        "is_table": false,
        "fields": [
          {
            "name": "value",
            "type": {
              "name": "bool",
              "is_array": false,
              "metadata": [0, 0]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "stream_owner_only",
      "parameters": null,
      "public": false,
      "modifiers": ["VIEW"],
      "body": "if is_stream_owner(@caller) == false  {\n        error('Stream owner only procedure');\n    }",
      "return_types": null,
      "annotations": null
    },
    {
      "name": "init",
      "parameters": null,
      "public": true,
      "modifiers": ["OWNER"],
      "body": "if is_initiated() {\n        error('this contract was already initialized');\n    }\n\n    // check if caller is empty\n    // this happens can happen in tests, but we should also protect for that on production\n    if @caller == '' {\n        error('caller is empty');\n    }\n\n    $current_block int := @height;\n\n    // uuid's namespaces are any random generated uuid from https://www.uuidtools.com/v5\n    // but each usage should be different to maintain determinism, so we reuse the previous result\n    $current_uuid uuid := uuid_generate_v5('111bfa42-17a2-11ef-bf03-325096b39f47'::uuid, @txid);\n\n    // type = primitive\n    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);\n    INSERT INTO metadata (row_id, metadata_key, value_s, created_at)\n        VALUES ($current_uuid, 'type', 'primitive', $current_block);\n\n    // stream_owner = @caller\n    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);\n    INSERT INTO metadata (row_id, metadata_key, value_ref, created_at)\n        VALUES ($current_uuid, 'stream_owner', LOWER(@caller), 1);\n\n    // compose_visibility = 0 (public)\n    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);\n    INSERT INTO metadata (row_id, metadata_key, value_i, created_at)\n        VALUES ($current_uuid, 'compose_visibility', 0, $current_block);\n\n    // read_visibility = 0 (public)\n    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);\n    INSERT INTO metadata (row_id, metadata_key, value_i, created_at)\n        VALUES ($current_uuid, 'read_visibility', 0, $current_block);\n\n    $readonly_keys text[] := [\n        'type',\n        'stream_owner',\n        'readonly_key'\n    ];\n\n    for $key in $readonly_keys {\n        $current_uuid :=  uuid_generate_v5($current_uuid, @txid);\n        INSERT INTO metadata (row_id, metadata_key, value_s, created_at)\n            VALUES ($current_uuid, 'readonly_key', $key, $current_block);\n    }",
      "return_types": null,
      "annotations": null
    },
    {
      "name": "insert_metadata",
      "parameters": [
        {
          "name": "$key",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$value",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$val_type",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": null,
      "body": "$value_i int;\n    $value_s text;\n    $value_f decimal(36,18);\n    $value_b bool;\n    $value_ref text;\n\n    if $val_type == 'int' {\n        $value_i := $value::int;\n    } elseif $val_type == 'string' {\n        $value_s := $value;\n    } elseif $val_type == 'bool' {\n        $value_b := $value::bool;\n    } elseif $val_type == 'ref' {\n        $value_ref := $value;\n    } elseif $val_type == 'float' {\n        $value_f := $value::decimal(36,18);\n    } else {\n        error(format('unknown type used \"%s\". valid types = \"float\" | \"bool\" | \"int\" | \"ref\" | \"string\"', $val_type));\n    }\n\n    stream_owner_only();\n\n    if is_initiated() == false {\n        error('contract must be initiated');\n    }\n\n    // check if it's read-only\n    for $row in SELECT * FROM metadata WHERE metadata_key = 'readonly_key' AND value_s = $key LIMIT 1 {\n        error('Cannot insert metadata for read-only key');\n    }\n\n    // we create one deterministic uuid for each metadata record\n    // we can't use just @txid because a single transaction can insert multiple metadata records.\n    // the result will be idempotency here too.\n    $uuid_key := @txid || $key || $value;\n\n    $uuid uuid := uuid_generate_v5('1361df5d-0230-47b3-b2c1-37950cf51fe9'::uuid, $uuid_key);\n    $current_block int := @height;\n\n    // insert data\n    INSERT INTO metadata (row_id, metadata_key, value_i, value_f, value_s, value_b, value_ref, created_at)\n        VALUES ($uuid, $key, $value_i, $value_f, $value_s, $value_b, LOWER($value_ref), $current_block);",
      "return_types": null,
      "annotations": null
    },
    {
      "name": "get_metadata",
      "parameters": [
        {
          "name": "$key",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$only_latest",
          "type": {
            "name": "bool",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$ref",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": ["VIEW"],
      "body": "if $only_latest == true {\n            if $ref is distinct from null {\n                return SELECT\n                              row_id,\n                              null::int as value_i,\n                              null::decimal(36,18) as value_f,\n                              null::bool as value_b,\n                              null::text as value_s,\n                              value_ref,\n                              created_at\n                FROM metadata\n                WHERE metadata_key = $key AND disabled_at IS NULL AND value_ref = LOWER($ref)\n                ORDER BY created_at DESC\n                LIMIT 1;\n            } else {\n                return SELECT\n                              row_id,\n                              value_i,\n                              value_f,\n                              value_b,\n                              value_s,\n                              value_ref,\n                              created_at\n                FROM metadata\n                WHERE metadata_key = $key AND disabled_at IS NULL\n                ORDER BY created_at DESC\n                LIMIT 1;\n            }\n        } else {\n           // SHOULD BE THE EXACT CODE AS ABOVE, BUT WITHOUT LIMIT\n           if $ref is distinct from null {\n               return SELECT\n                             row_id,\n                             null::int as value_i,\n                             null::decimal(36,18) as value_f,\n                             null::bool as value_b,\n                             null::text as value_s,\n                             value_ref,\n                             created_at\n                FROM metadata\n                WHERE metadata_key = $key AND disabled_at IS NULL AND value_ref = LOWER($ref)\n                ORDER BY created_at DESC;\n           } else {\n               return SELECT\n                             row_id,\n                             value_i,\n                             value_f,\n                             value_b,\n                             value_s,\n                             value_ref,\n                             created_at\n               FROM metadata\n               WHERE metadata_key = $key AND disabled_at IS NULL\n               ORDER BY created_at DESC;\n           }\n        }",
      "return_types": {
        "is_table": true,
        "fields": [
          {
            "name": "row_id",
            "type": {
              "name": "uuid",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "value_i",
            "type": {
              "name": "int",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "value_f",
            "type": {
              "name": "decimal",
              "is_array": false,
              "metadata": [36, 18]
            }
          },
          {
            "name": "value_b",
            "type": {
              "name": "bool",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "value_s",
            "type": {
              "name": "text",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "value_ref",
            "type": {
              "name": "text",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "created_at",
            "type": {
              "name": "int",
              "is_array": false,
              "metadata": [0, 0]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "disable_metadata",
      "parameters": [
        {
          "name": "$row_id",
          "type": {
            "name": "uuid",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": null,
      "body": "stream_owner_only();\n\n    $current_block int := @height;\n\n    $found bool := false;\n\n    // Check if the metadata is not read-only\n    for $metadata_row in\n    SELECT metadata_key\n    FROM metadata\n    WHERE row_id = $row_id AND disabled_at IS NULL\n    LIMIT 1 {\n        $found := true;\n        $row_key text := $metadata_row.metadata_key;\n\n        for $readonly_row in SELECT row_id FROM metadata WHERE metadata_key = 'readonly_key' AND value_s = $row_key LIMIT 1 {\n            error('Cannot disable read-only metadata');\n        }\n\n        UPDATE metadata SET disabled_at = $current_block\n        WHERE row_id = $row_id;\n    }\n\n    if $found == false {\n        error('metadata record not found');\n    }",
      "return_types": null,
      "annotations": null
    },
    {
      "name": "insert_record",
      "parameters": [
        {
          "name": "$date_value",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$value",
          "type": {
            "name": "decimal",
            "is_array": false,
            "metadata": [36, 18]
          }
        }
      ],
      "public": true,
      "modifiers": null,
      "body": "if is_wallet_allowed_to_write(@caller) == false {\n        error('wallet not allowed to write');\n    }\n\n    if is_initiated() == false {\n        error('contract must be initiated');\n    }\n\n    $current_block int := @height;\n\n    // insert data\n    INSERT INTO primitive_events (date_value, value, created_at)\n        VALUES ($date_value, $value, $current_block);",
      "return_types": null,
      "annotations": null
    },
    {
      "name": "get_index",
      "parameters": [
        {
          "name": "$date_from",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$date_to",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$frozen_at",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$base_date",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": ["VIEW"],
      "body": "$baseValue decimal(36,18) := get_base_value($base_date, $frozen_at);\n    if $baseValue == 0::decimal(36,18) {\n        error('base value is 0');\n    }\n\n    return SELECT date_value, (value * 100::decimal(36,18)) / $baseValue as value FROM get_record($date_from, $date_to, $frozen_at);",
      "return_types": {
        "is_table": true,
        "fields": [
          {
            "name": "date_value",
            "type": {
              "name": "text",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "value",
            "type": {
              "name": "decimal",
              "is_array": false,
              "metadata": [36, 18]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "get_base_value",
      "parameters": [
        {
          "name": "$base_date",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$frozen_at",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": false,
      "modifiers": ["VIEW"],
      "body": "if $base_date is null OR $base_date = '' {\n        for $row in SELECT * FROM primitive_events WHERE (created_at \u003c= $frozen_at OR $frozen_at = 0 OR $frozen_at IS NULL) ORDER BY date_value ASC, created_at DESC LIMIT 1 {\n            return $row.value;\n        }\n    }\n\n    for $row2 in SELECT * FROM primitive_events WHERE date_value \u003c= $base_date AND (created_at \u003c= $frozen_at OR $frozen_at = 0 OR $frozen_at IS NULL) ORDER BY date_value DESC, created_at DESC LIMIT 1 {\n        return $row2.value;\n    }\n\n    // if no value is found, we find the first value after the given date\n    // This will raise a red flag in the system and the data will undergo the usual process for when a new data provider is added.\n    for $row3 in SELECT * FROM primitive_events WHERE date_value \u003e $base_date AND (created_at \u003c= $frozen_at OR $frozen_at = 0 OR $frozen_at IS NULL) ORDER BY date_value ASC, created_at DESC LIMIT 1 {\n        return $row3.value;\n    }\n\n    // if no value is found, we return an error\n    error('no base value found');",
      "return_types": {
        "is_table": false,
        "fields": [
          {
            "name": "value",
            "type": {
              "name": "decimal",
              "is_array": false,
              "metadata": [36, 18]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "get_first_record",
      "parameters": [
        {
          "name": "$after_date",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$frozen_at",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": ["VIEW"],
      "body": "if is_wallet_allowed_to_read(@caller) == false {\n        error('wallet not allowed to read');\n    }\n\n    // check compose access\n    is_stream_allowed_to_compose(@foreign_caller);\n\n    // let's coalesce after_date with ''\n    // then, if it's empty, it will always be the first value\n    if $after_date is null {\n        $after_date := '';\n    }\n\n    // coalesce frozen_at with 0\n    if $frozen_at is null {\n        $frozen_at := 0;\n    }\n\n    return SELECT date_value, value FROM primitive_events WHERE date_value \u003e= $after_date AND (created_at \u003c= $frozen_at OR $frozen_at = 0 OR $frozen_at IS NULL) ORDER BY date_value ASC, created_at DESC LIMIT 1;",
      "return_types": {
        "is_table": true,
        "fields": [
          {
            "name": "date_value",
            "type": {
              "name": "text",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "value",
            "type": {
              "name": "decimal",
              "is_array": false,
              "metadata": [36, 18]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "get_original_record",
      "parameters": [
        {
          "name": "$date_from",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$date_to",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$frozen_at",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": false,
      "modifiers": ["VIEW"],
      "body": "check_valid_date_or_null($date_from, 'date_from');\n    check_valid_date_or_null($date_to, 'date_to');\n\n    // check read access\n    if is_wallet_allowed_to_read(@caller) == false {\n        error('wallet not allowed to read');\n    }\n    // check compose access\n    is_stream_allowed_to_compose(@foreign_caller);\n\n    $frozenValue int := 0;\n    if $frozen_at IS DISTINCT FROM NULL {\n        $frozenValue := $frozen_at::int;\n    }\n\n    // TODO: whereClause here is a placeholder only, not supported yet, but it will make things cleaner if it available\n    //$whereClause text := 'WHERE 1=1 ';\n    //if $date_from != '' {\n    //    $whereClause := $whereClause || 'AND date_value \u003e= $date_from ';\n    //}\n\n    //if $date_to != '' {\n    //    $whereClause := $whereClause || 'AND date_value \u003c= $date_to ';\n    //}\n\n\n    // TODO: Normally we would use the following query to get the latest value of each date\n    // But it's not working for JOIN and MAX() function\n    //for $row in SELECT date_value, value FROM primitive_events JOIN (SELECT date_value, MAX(created_at) as created_at FROM primitive_events GROUP BY date_value) as max_created\n    //ON primitive_events.date_value = max_created.date_value AND primitive_events.created_at = max_created.created_at\n    //$whereClause\n    //ORDER BY date_value DESC {\n    //    return next $row.date_value, $row.value;\n    //}\n\n   // TODO: had to use this workaround because \u0026\u0026 operator is not working\n   $last_result_date text := '';\n   if $date_from IS DISTINCT FROM NULL {\n       if $date_to IS DISTINCT FROM NULL {\n           // date_from and date_to are provided\n           // we will fetch all records from date_from to date_to\n           for $row in SELECT date_value, value FROM primitive_events\n               WHERE date_value \u003e= $date_from AND date_value \u003c= $date_to\n               AND (created_at \u003c= $frozenValue OR $frozenValue = 0)\n               AND $last_result_date != date_value\n               ORDER BY date_value DESC, created_at DESC {\n                   if $last_result_date != $row.date_value {\n                        $last_result_date := $row.date_value;\n                       return next $row.date_value, $row.value;\n                   }\n               }\n       } else {\n           // only date_from is provided\n           // we will fetch all records from date_from to the latest\n           for $row2 in SELECT date_value, value FROM primitive_events\n               WHERE date_value \u003e= $date_from\n               AND (created_at \u003c= $frozenValue OR $frozenValue = 0)\n               AND $last_result_date != date_value\n               ORDER BY date_value DESC, created_at DESC {\n                   if $last_result_date != $row2.date_value {\n                        $last_result_date := $row2.date_value;\n                       return next $row2.date_value, $row2.value;\n                   }\n               }\n        }\n   } else {\n       if $date_to IS NOT DISTINCT FROM NULL {\n           // no date_from and date_to provided\n           // we fetch only the latest record\n           return SELECT date_value, value FROM primitive_events\n               WHERE created_at \u003c= $frozenValue OR $frozenValue = 0\n               AND $last_result_date != date_value\n               ORDER BY date_value DESC, created_at DESC LIMIT 1;\n       } else {\n           // date_to is provided but date_from is not\n           error('date_from is required if date_to is provided');\n       }\n   }",
      "return_types": {
        "is_table": true,
        "fields": [
          {
            "name": "date_value",
            "type": {
              "name": "text",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "value",
            "type": {
              "name": "decimal",
              "is_array": false,
              "metadata": [36, 18]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "get_record",
      "parameters": [
        {
          "name": "$date_from",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$date_to",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$frozen_at",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": ["VIEW"],
      "body": "$is_first_result bool := true;\n\n    for $row in SELECT * FROM get_original_record($date_from, $date_to, $frozen_at) {\n        // we will only fetch the last record before the first result\n        // if the first result is not the same as the start date\n        if $is_first_result == true {\n            $first_result_date text := $row.date_value;\n\n            // if the first result date is not the same as the start date, then we need to fetch the last record before it\n            if $first_result_date != $date_from {\n                for $last_row in SELECT * FROM get_last_record_before_date($first_result_date) {\n                    // Note: although the user requested a date_from, we are returning the previous date here\n                    // e.g., the user used date_from:2021-01-02, and we are returning 2021-01-01 as first value\n                    //\n                    // that happens because the accuracy is guaranteed with this behavior, otherwise the\n                    // user won't be able to know when a data point really exist in our database or not.\n\n                    return next $last_row.date_value, $last_row.value;\n                }\n            }\n\n            $is_first_result := false;\n        }\n\n        return next $row.date_value, $row.value;\n    }\n\n    // it's still the first result? i.e. there were no results\n    // so let's try finding the last record before the start date\n    if $is_first_result == true {\n        for $last_row2 in SELECT * FROM get_last_record_before_date($date_from) {\n            return next $last_row2.date_value, $last_row2.value;\n        }\n    }",
      "return_types": {
        "is_table": true,
        "fields": [
          {
            "name": "date_value",
            "type": {
              "name": "text",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "value",
            "type": {
              "name": "decimal",
              "is_array": false,
              "metadata": [36, 18]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "get_last_record_before_date",
      "parameters": [
        {
          "name": "$date_from",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": ["VIEW"],
      "body": "return SELECT date_value, value FROM primitive_events WHERE date_value \u003c $date_from ORDER BY date_value DESC, created_at DESC LIMIT 1;",
      "return_types": {
        "is_table": true,
        "fields": [
          {
            "name": "date_value",
            "type": {
              "name": "text",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "value",
            "type": {
              "name": "decimal",
              "is_array": false,
              "metadata": [36, 18]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "transfer_stream_ownership",
      "parameters": [
        {
          "name": "$new_owner",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": null,
      "body": "stream_owner_only();\n\n    // fail if not a valid address\n    check_eth_address($new_owner);\n\n    UPDATE metadata SET value_ref = LOWER($new_owner)\n    WHERE metadata_key = 'stream_owner';",
      "return_types": null,
      "annotations": null
    },
    {
      "name": "check_eth_address",
      "parameters": [
        {
          "name": "$address",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": false,
      "modifiers": null,
      "body": "if (length($address) != 42) {\n        error('invalid address length');\n    }\n\n    // check if starts with 0x\n    for $row in SELECT $address LIKE '0x%' as a {\n        if $row.a == false {\n            error('address does not start with 0x');\n        }\n    }",
      "return_types": null,
      "annotations": null
    },
    {
      "name": "is_stream_allowed_to_compose",
      "parameters": [
        {
          "name": "$foreign_caller",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": ["VIEW"],
      "body": "if $foreign_caller == '' {\n        return true;\n    }\n\n    // if public, anyone can always read\n    // If there's no visibility metadata, it's public.\n    $visibility int := 0;\n    for $v_row in SELECT * FROM get_metadata('compose_visibility', true, null) {\n        $visibility := $v_row.value_i;\n    }\n\n    if $visibility == 0 {\n        return true;\n    }\n\n    // if there's metadata allow_compose_stream -\u003e \u003cforeign_caller\u003e, then its permitted\n    for $row in SELECT * FROM get_metadata('allow_compose_stream', true, $foreign_caller) LIMIT 1 {\n        return true;\n    }\n\n    error('stream not allowed to compose');",
      "return_types": {
        "is_table": false,
        "fields": [
          {
            "name": "value",
            "type": {
              "name": "bool",
              "is_array": false,
              "metadata": [0, 0]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "get_index_change",
      "parameters": [
        {
          "name": "$date_from",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$date_to",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$frozen_at",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$base_date",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$days_interval",
          "type": {
            "name": "int",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": true,
      "modifiers": ["VIEW"],
      "body": "if $frozen_at == null {\n        $frozen_at := 0;\n    }\n\n    if $days_interval == null {\n        error('days_interval is required');\n    }\n\n    $current_values decimal(36,18)[];\n    // example: [01-2001, 05-2001, 09-2001, 10-2001]\n    $current_dates text[];\n    // example: [01-2000, 05-2000, 09-2000, 10-2000]\n    $expected_prev_dates text[];\n\n    for $row_current in SELECT * FROM get_index($date_from, $date_to, $frozen_at, $base_date) {\n        $prev_date := format_unix_timestamp((parse_unix_timestamp($row_current.date_value, 'yyyy-MM-dd')::int - ($days_interval * 86400))::decimal(16,6), 'yyyy-MM-dd');\n        $expected_prev_dates := array_append($expected_prev_dates, $prev_date);\n        $current_values := array_append($current_values, $row_current.value);\n        $current_dates := array_append($current_dates, $row_current.date_value);\n    }\n\n    // example: 01-2000]\n    $earliest_prev_date := $expected_prev_dates[1];\n    // example: 09-2000\n    $latest_prev_date := $expected_prev_dates[array_length($expected_prev_dates)];\n\n    // real previous values doesn't match the same length as expected previous dates\n    // because the interval can have much more values than the expected dates\n    $real_prev_values decimal(36,18)[];\n    $real_prev_dates text[];\n\n    // now we query the prev dates\n    for $row_prev in SELECT * FROM get_index($earliest_prev_date, $latest_prev_date, $frozen_at, $base_date) {\n        $real_prev_values := array_append($real_prev_values, $row_prev.value);\n        $real_prev_dates := array_append($real_prev_dates, $row_prev.date_value);\n    }\n\n    // now we calculate the matching dates for the real prev values\n    $result_prev_dates text[];\n    $result_prev_values decimal(36,18)[];\n\n    $real_prev_date_idx int := 1;\n\n    // for each expected prev date, we find the matching real prev date\n    if array_length($expected_prev_dates) \u003e 0 {\n        for $expected_prev_date_idx in 1..array_length($expected_prev_dates) {\n            // we start from the last index of real prev dates. we don't need to check previous values\n            for $selector in $real_prev_date_idx..array_length($real_prev_dates) {\n                // if next real prev date is greater than expected prev date (or null), then we need to use the current real value\n                if $real_prev_dates[$selector + 1] \u003e $expected_prev_dates[$expected_prev_date_idx]\n                   OR $real_prev_dates[$selector + 1] IS NULL {\n                    // if the current real prev date is already greater than expected prev date\n                    // we use NULL. We're probably before the first real prev date here\n                    if $real_prev_dates[$selector] \u003e $expected_prev_dates[$expected_prev_date_idx] {\n                        $result_prev_dates := array_append($result_prev_dates, null::text);\n                        $result_prev_values := array_append($result_prev_values, null::decimal(36,18));\n                    } else {\n                        $result_prev_dates := array_append($result_prev_dates, $real_prev_dates[$selector]);\n                        $result_prev_values := array_append($result_prev_values, $real_prev_values[$selector]);\n                    }\n                    // we already appended one for current $real_prev_date_idx, then we need to go to next\n                    $real_prev_date_idx := $selector;\n                    break;\n                }\n            }\n        }\n    }\n\n    // check if we have the same number of values and dates\n    if array_length($current_dates) != array_length($result_prev_dates) {\n        error('we have different number of dates and values');\n    }\n    if array_length($current_values) != array_length($result_prev_values) {\n        error('we have different number of dates and values');\n    }\n\n    // calculate the index change\n    if array_length($result_prev_dates) \u003e 0 {\n        for $row_result in 1..array_length($result_prev_dates) {\n            // if the expected_prev_date is null, then we don't have a real prev date\n            if $result_prev_dates[$row_result] IS DISTINCT FROM NULL {\n                return next $current_dates[$row_result], ($current_values[$row_result] - $result_prev_values[$row_result]) * 100.00::decimal(36,18) / $result_prev_values[$row_result];\n            }\n        }\n    }",
      "return_types": {
        "is_table": true,
        "fields": [
          {
            "name": "date_value",
            "type": {
              "name": "text",
              "is_array": false,
              "metadata": [0, 0]
            }
          },
          {
            "name": "value",
            "type": {
              "name": "decimal",
              "is_array": false,
              "metadata": [36, 18]
            }
          }
        ]
      },
      "annotations": null
    },
    {
      "name": "check_valid_date_or_null",
      "parameters": [
        {
          "name": "$date",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        },
        {
          "name": "$name",
          "type": {
            "name": "text",
            "is_array": false,
            "metadata": [0, 0]
          }
        }
      ],
      "public": false,
      "modifiers": ["VIEW"],
      "body": "if $date IS DISTINCT FROM NULL {\n        if length($date) != 10 {\n            error(format('%s must be in yyyy-mm-dd format or should not be provided: received %s', $name, $date));\n        }\n    }",
      "return_types": null,
      "annotations": null
    }
  ],
  "foreign_calls": null
}
